export const exportToPdf = () => {
    window.print();
};

export const exportToTxt = (title: string, content: string) => {
    const element = document.createElement("a");
    const file = new Blob([content], { type: "text/plain" });
    element.href = URL.createObjectURL(file);
    element.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.txt`;
    document.body.appendChild(element); // Required for this to work in FireFox
    element.click();
    document.body.removeChild(element);
};

export const exportToDocx = async (title: string, htmlContent: string) => {
    // Basic HTML to DOCX approach using a Blob with MIME type
    // Note: This is a simple "save as .doc" trick often accepted by Word, 
    // real .docx generation requires a heavy library like docx.js.
    // Given the constraints to stay lightweight, we'll use HTML-based export.

    const preHtml = "<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'><head><meta charset='utf-8'><title>Export HTML To Doc</title></head><body>";
    const postHtml = "</body></html>";
    const html = preHtml + htmlContent + postHtml;

    const blob = new Blob(['\ifeff', html], {
        type: 'application/msword'
    });

    // Create download link
    const url = 'data:application/vnd.ms-word;charset=utf-8,' + encodeURIComponent(html);

    const downloadLink = document.createElement("a");
    document.body.appendChild(downloadLink);

    if ((navigator as any).msSaveOrOpenBlob) {
        (navigator as any).msSaveOrOpenBlob(blob, `${title}.doc`);
    } else {
        downloadLink.href = url;
        downloadLink.download = `${title}.doc`;
        downloadLink.click();
    }

    document.body.removeChild(downloadLink);
};

export const copyToClipboard = async (text: string): Promise<boolean> => {
    try {
        await navigator.clipboard.writeText(text);
        return true;
    } catch (err) {
        console.error("Failed to copy:", err);
        return false;
    }
};

export const formatFlashcardsForExport = (title: string, cards: { front: string; back: string }[]) => {
    let text = `FLASHCARDS: ${title}\n\n`;
    text += `Generated by QuizBolt\n`;
    text += `====================================\n\n`;

    cards.forEach((card, idx) => {
        text += `Card ${idx + 1}:\n`;
        text += `Q: ${card.front}\n`;
        text += `A: ${card.back}\n`;
        text += `------------------------------------\n\n`;
    });

    return text;
};

export const formatQuizForExport = (title: string, questions: { questionText: string; options: string[] }[]) => {
    let text = `QUIZ: ${title}\n\n`;
    questions.forEach((q, idx) => {
        text += `${idx + 1}. ${q.questionText}\n`;
        q.options.forEach((opt, oIdx) => {
            text += `   ${String.fromCharCode(65 + oIdx)}. ${opt}\n`;
        });
        text += `\n`;
    });
    return text;
};


export const formatQuizWithAnswersForExport = (title: string, questions: { questionText: string; options: string[]; correctOption: number; explanation?: string }[]) => {
    let text = `QUIZ ANSWER KEY: ${title}\n\n`;
    questions.forEach((q, idx) => {
        text += `${idx + 1}. ${q.questionText}\n`;
        text += `   ANSWER: ${String.fromCharCode(65 + q.correctOption)} (${q.options[q.correctOption]})\n`;
        if (q.explanation) {
            text += `   EXPLANATION: ${q.explanation}\n`;
        }
        text += `\n`;
    });
    return text;
};

export const formatQuizBlankForExport = (title: string, questions: { questionText: string; options: string[] }[]) => {
    let text = `QUIZ: ${title}\n\n`;
    text += `Name: __________________________\n`;
    text += `Date: __________________________\n\n`;
    questions.forEach((q, idx) => {
        text += `${idx + 1}. ${q.questionText}\n`;
        q.options.forEach((opt, oIdx) => {
            text += `   [ ] ${String.fromCharCode(65 + oIdx)}. ${opt}\n`;
        });
        text += `\n`;
    });
    return text;
};
